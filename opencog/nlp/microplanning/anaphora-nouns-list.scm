; loading additional dependency
(use-modules (oop goops))
(load-scm-from-file "../opencog/nlp/microplanning/anaphora-noun-item.scm")

; -----------------------------------------------------------------------
; <nouns-list> -- A class containing a list of <noun-item>
;
; A <nouns-list> is generated by extracting all noun nodes from the links
; in a chunk.  This class contains a bunch of method for acting on such
; a list.
;
(define-class <nouns-list> ()
	(lst #:init-value '())
)

; -----------------------------------------------------------------------
; get-length -- Get the length of a <nouns-list>
;
(define-method (get-length (nl <nouns-list>))
	(length (slot-ref nl 'lst))
)

; -----------------------------------------------------------------------
; add-noun-item -- Add a <noun-item> to the <nouns-list>
;
(define-method (add-noun-item (nl <nouns-list>) (ni <noun-item>))
	(slot-set! nl 'lst (append (slot-ref nl 'lst) (list ni)))
)

; -----------------------------------------------------------------------
; get-noun-item -- Get a <noun-item> from the <nouns-list> base on 'index'
;
(define-method (get-noun-item (nl <nouns-list>) (index <integer>))
	(list-ref (slot-ref nl 'lst) index)
)

; -----------------------------------------------------------------------
; get-sublist -- Returns a new <nouns-list> that is a sublist of the original
;
; Note that objects in Scheme are passed by reference, so that means the
; <noun-item> in the new sublist is the same as the original.  Modifying
; a <noun-item> in one list will also appear changed in the other.
;
(define-method (get-sublist (nl <nouns-list>) (start-index <integer>) (end-index <integer>))
	(define new-list (make <nouns-list>))
	(slot-set! new-list 'lst (sublist (slot-ref nl 'lst) start-index end-index))
	new-list
)

; -----------------------------------------------------------------------
; get-chunk-sublist -- Get a new sublist bases on 'chunk-index' of each <noun-item>
;
(define-method (get-chunk-sublist (nl <nouns-list>) (chunk-index <integer>))
	; find subset of nouns-list that share the same chunk number
	(define start-index (list-index (lambda (n) (= chunk-index (get-chunk-index n))) (slot-ref nl 'lst)))
	(define end-index (list-index (lambda (n) (< chunk-index (get-chunk-index n))) (slot-ref nl 'lst)))

	; makes it so that we will return an empty subset if a chunk does not need to be changed
	; (eg. if a chunk somehow has no noun)
	(if (not start-index)
		(set! start-index (get-length nl))
	)
	; if we have reached the end of the set
	(if (not end-index)
		(set! end-index (get-length nl))
	)

	(get-sublist nl start-index end-index)
)

; -----------------------------------------------------------------------
; get-chunk-link-sublist -- Get a new sublist bases on the 'chunk-index' and 'link-index'
;
(define-method (get-chunk-link-sublist (nl <nouns-list>) (chunk-index <integer>) (link-index <integer>))
	(define chunk-sublist (get-chunk-sublist nl chunk-index))
	
	; find subset of chunk-sublist that share the same link number
	(define start-index (list-index (lambda (n) (= link-index (get-link-index n))) (slot-ref chunk-sublist 'lst)))
	(define end-index (list-index (lambda (n) (< link-index (get-link-index n))) (slot-ref chunk-sublist 'lst)))

	; makes it so that we will return an empty subset if a link does not need to be changed
	; (eg. if a link does not contain a noun)
	(if (not start-index)
		(set! start-index (get-length chunk-sublist))
	)

	; if we have reached the end of the subset
	(if (not end-index)
		(set! end-index (get-length chunk-sublist))
	)
	
	(get-sublist chunk-sublist start-index end-index)
)

; -----------------------------------------------------------------------
; find-by-proc -- Find the first <noun-item> where 'proc' return #t
;
; 'proc' needs to be a normal Scheme procedure (not <generic>) but must
; accept a <noun-item> as the parameter.
;
(define-method (find-by-proc (nl <nouns-list>) (proc <procedure>))
	(find proc (slot-ref nl 'lst))
)

; -----------------------------------------------------------------------
; is-modified -- Check a <noun-item> to see if it is modified
;
; Modified means things like adjectives, so it will check the chunk in
; which the <noun-item> is in for InheritanceLink which contains the
; same noun ConceptNode.
;
(define-method (is-modified? (nl <nouns-list>) (ni <noun-item>))
	; TODO add check where within the same chunk one noun appear multiple times
	;      and only one of them is modified
	;      eg.  "Bob collects the tiny seeds and plants seeds."
	; XXX  might need to call SuReal to do the above check
	(any (lambda (n) 
		(and (= (get-chunk-index n) (get-chunk-index ni))		; in the same chunk?
		     (equal? (get-noun-node n) (get-noun-node ni))		; with the same node?
		     (equal? 'InheritanceLink (cog-type (get-orig-link n)))	; in InheritanceLink modifying the noun (amod-rule)
		)
	     )
	     (slot-ref nl 'lst)
	)
)

; -----------------------------------------------------------------------
; is-ambiguous? -- Check a <noun-item> to see if it is ambiguous if pronoun-ed
;
; Check the neighboring subject/object/indirect-object and see if changing
; <noun-item> to pronoun will be ambiguious.
;
(define-method (is-ambiguous? (nl <nouns-list>) (ni <noun-item>))
	(define index (list-index equal? (slot-ref nl 'lst) (circular-list ni)))
	(define min-index (max 0 (- index 3))) ; inclusive
	(define max-index (min (get-length nl) (+ index 3))) ; exclusive

	; check how many pronouns in subset equals ni's (except itself)
	(> (count
		(lambda (n) (and (not (equal? 'InheritanceLink (cog-type (get-orig-link n)))) ; exclude modifying link from amod-rule
				 (not (equal? (get-noun-node n) (get-noun-node ni)))
				 (string=? (get-base-pronominal n) (get-base-pronominal ni))))
		(sublist (slot-ref nl 'lst) min-index max-index)
	   )
	   0
	)

	; TODO sometimes it is OK depends on the main subject (current and previous sentence)
	; (eg.  John helped Sam to prepare his project.)
	; (eg.  John helped Sam to feed himself.)
)

; -----------------------------------------------------------------------
; is-ancient? -- Check if <noun-item> was mentioned too long ago
;
; Check if <noun-item> was mentioned more than 3 sentences ago, makes it
; difficult to understand if changed to a pronoun.
;
(define-method (is-ancient? (nl <nouns-list>) (ni <noun-item>))
	(define index (list-index equal? (slot-ref nl 'lst) (circular-list ni)))
	(define (get-last-time ind)
		(if (< ind 0)
			'()
			; get the noun-item at index 'ind'
			(let ((n (list-ref (slot-ref nl 'lst) ind)))
				(if (and (equal? (get-noun-node n) (get-noun-node ni))			; same noun instance
					 (not (equal? 'InheritanceLink (cog-type (get-orig-link n)))))	; not a modifying link (amod-rule)
					n
					(get-last-time (- ind 1))
				)
			)
		)
	)
	(define last-occurrence (get-last-time (- index 1)))

	; a noun is ancient if appearing more than 3 sentences ago, or not at all
	(or (null? last-occurrence) (< (+ 3 (get-chunk-index last-occurrence)) (get-chunk-index ni)))
)

; -----------------------------------------------------------------------
; update-pronoun-safety -- Update the 'pronoun-safe' flag in a <noun-item>
;
; Check all <noun-item>s in the <nouns-list> against each other and update
; the 'pronoun-safe' flag as neccessary.
;
(define-method (update-pronoun-safety (nl <nouns-list>))
	(define (is-safe? ni)
		(not (or (is-ancient? nl ni) (is-ambiguous? nl ni) (is-modified? nl ni)))	
	)

	(for-each
		(lambda (n) (set-pronoun-safe! n (is-safe? n)))
		(slot-ref nl 'lst)
	)
)

; -----------------------------------------------------------------------
; populate-nouns-list -- Populate the <nouns-list> by extracting from 'chunks'
;
; Check all the chunk in 'chunks' and extract nouns.  Create the
; corressponding <noun-item> and add it to the list.  Update the pronoun-safe
; flag after the list is populated.
;
(define-method (populate-nouns-list (nl <nouns-list>) (chunks <list>))
	(define atom-index 0)

	; for each chunk
	(for-each
		(lambda (c chunk-index)
			; for each link in a chunk
			(for-each
				(lambda (link link-index)
					(set! atom-index 0)
					; for each node in a link
					(for-each
						(lambda (node)
							(if (word-inst-is-noun? (r2l-get-word-inst node))
								(add-noun-item
									nl
									(make <noun-item>
										#:noun-node node
										#:orig-link link
										#:atom-index atom-index
										#:link-index link-index
										#:chunk-index chunk-index
									)
								)
							)
							(set! atom-index (+ 1 atom-index))
						)
						(cog-get-all-nodes link)					
					)
				)
				c
				(iota (length c)) ; generate link-indices
			)				
		)
		chunks
		(iota (length chunks)) ; generate chunk-indices
	)

	; determine pronoun safety bases on the current set of chunks
	(update-pronoun-safety nl)
)
