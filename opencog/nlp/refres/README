
                         Reference Resolution
                         --------------------
                             October 2008
                             Linas Vepstas

The core problem of reference resolution is determining when two words
in a text refer to the same concept. Thus, for example, the same noun,
used in neighboring sentences, probably refers to the same concept.
Alternately, anaphora (he, she, it, etc.) may also be used to refer to
the same concept.

This README file contains some working notes on how reference resolution
might be accomplished within the current OpenCog infrastructure. These
notes may at times be incoherent or disconnnected; this is a
work-in-progress.

Overview
========
The current plan is to perform reference resolution using a collection
of "rules" or "proceedures" to recognize likely co-referents, and then
to check for reference consistency using reasoning. An example of a set
of rules is the "Hobbs algorithm" for anaphora resolution. 

The goal here is to implement all of these rules/algorithms as a set of 
OpenCog hypergraphs. The reason for doing this is to allow the system to
automatically learn, reinforce, and modify these sets of rules.  Thus,
for example, the Hobbs algo has been implemented in Java, as a part of 
the RelEx package. However, if changes are needed to this algorithm are
needed, then only a human programmer is capable of performing these
changes, as only a human programmer can (currently) understand Java and 
make meaningful modifications to Java code.  By contrast, the goal here
is to perform a statistical analysis of text, and to automatically
discover such rules, as best as possible, assign them likelyhoods and
weights that correspond to thier suitability in any given linguistic
situation.

There are then four practical considerations to acheiving the above
program:
1) Understanding how to represent "rules" as OpenCog hypergraphs
2) Having a "rule engine" that can apply these rules.
3) Having a persistent database that can accumulate statistical
   information about the usage of these rules,
4) Having a "perception" system that can spot rules ("features") 
   that have been useful, and further refine them, or spot weak
   rules, and reject them.

The fourth step seems to be the vaguest at this point. I hope to
combine ideas making use of mutual information, Markov networks and
Markov logic networks, and heirarchical feature selection to accomplish
this. The general idea is to be able to spot commonly-occuring patterns
or features, in much the same way that one might find patterns in
genetic data. 

It is expected that the system will be initially primed with a number
of hand-generated rules.

The first three issues are significant, practical barrirers to further
progress, and are thus tackled first.


Representing IF...THEN constructs in Opencog
============================================
The core idea is to find patterns in text, and then create new patterns
as a result. As the simplest example, a "pattern" would be finding all
instances of a noun in some block of text, assuming that all of these
nouns refer to the same thing, and so creating a ConceptNode that
encompases all of these noun instances.  This can be crudely represented
as the pseudo-code:

   IF (for-all parses of all sentences in same document)
       AND (word-instance-1 == noun)
       AND (word-of-word-instance-2 == word-of-word-instance-1) 
       AND ...
       AND (word-of-word-instance-k == word-of-word-instance-1)
   THEN (create concept-node encompassing word-instances 1 thru k)

It would be "easiest" to code up above in C++ or Scheme (or Java or 
Python or ...) but this missses the point: The opencog system will 
need to be able to modify the above rule (or algorithm) based on
learned, statistical experience, for example, by adding more 
AND-clauses to refine the action. 

Another example: The consistency of this reference assignment can be 
checked using the following pseudo-code:

   IF (word-instance-1 is-grouped-wth word-instance-2 in same concept)
      AND (word-instance-1 has property-A)
      AND (word-instance-2 has property-B)
      AND (property-A is inconnsistent with property-B)
   THEN (word-instance-1 and word-instance-2 should be ungrouped,
        and are probably distinct concepts)

The above pseudocode would help resolve text such as "Jurate held a red
balloon. Kastytis held a green balloon." The intitial reference
resolution would assign both word instances to the same object-instance
(i.e. assume that both words refer to just one balloon). The consistency
checker would note that the the color property is inconsistent, and thus
conclude that these are probably not refering to the same object. (And
tus, the combined-concept should be assigned a truth value close to
"false", and two new, distinct object-instance-concepts should be
created.

The core OpenCog nodes and links to be used to represent such rules are:
   VariableNode  -- to indicate a variable
   ImplicationLink -- to represent an if..then.. relationship.

Thus

   "If the case is near the mouse and the cat is hungry, the cat will
   eat the mouse".

   ImplicationLink
   ___ANDLink
   ______ Inheritance $var0 cat
   ______ Inheritance $var0 hungry
   ______ EvaluationLink
   ___________ Node near
   ___________ ListLink
   _______________VariableNode $var1
   _______________VariableNode $var0
   ______ InheritanceLink $var1 mouse
   ___EvaluationLink
   ______Node eat
   ___________VariableNode $var0
   ___________VaraibleNode $var1
   
   
