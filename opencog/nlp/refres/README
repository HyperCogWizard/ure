
                         Reference Resolution
                         --------------------
                             October 2008
                             Linas Vepstas

The core problem of reference resolution is determining when two words
in a text refer to the same concept. Thus, for example, the same noun,
used in neighboring sentences, probably refers to the same concept.
Alternately, anaphora (he, she, it, etc.) may also be used to refer to
the same concept.

This README file contains some working notes on how reference resolution
might be accomplished within the current OpenCog infrastructure. These
notes may at times be incoherent or disconnnected; this is a
work-in-progress.

Overview
========
The current plan is to perform reference resolution using a collection
of "rules" or "proceedures" to recognize likely co-referents, and then
to check for reference consistency using reasoning. An example of a set
of rules is the "Hobbs algorithm" for anaphora resolution.

The goal here is to implement all of these rules/algorithms as a set of
OpenCog hypergraphs. The reason for doing this is to allow the system to
automatically learn, reinforce, and modify these sets of rules.  Thus,
for example, the Hobbs algo has been implemented in Java, as a part of
the RelEx package. However, if changes are needed to this algorithm are
needed, then only a human programmer is capable of performing these
changes, as only a human programmer can (currently) understand Java and
make meaningful modifications to Java code.  By contrast, the goal here
is to perform a statistical analysis of text, and to automatically
discover such rules, as best as possible, assign them likelyhoods and
weights that correspond to thier suitability in any given linguistic
situation.

There are then four practical considerations to acheiving the above
program:
1) Understanding how to represent "rules" as OpenCog hypergraphs
2) Having a "rule engine" that can apply these rules.
3) Having a persistent database that can accumulate statistical
   information about the usage of these rules,
4) Having a "perception" system that can spot rules ("features")
   that have been useful, and further refine them, or spot weak
   rules, and reject them.

The fourth step seems to be the vaguest at this point. I hope to
combine ideas making use of mutual information, Markov networks and
Markov logic networks, and heirarchical feature selection to accomplish
this. The general idea is to be able to spot commonly-occuring patterns
or features, in much the same way that one might find patterns in
genetic data.

It is expected that the system will be initially primed with a number
of hand-generated rules.

The first three issues are significant, practical barrirers to further
progress, and are thus tackled first.


Representing IF...THEN constructs in OpenCog
============================================
The core idea is to find patterns in text, and then create new patterns
as a result. As the simplest example, a "pattern" would be finding all
instances of a noun in some block of text, assuming that all of these
nouns refer to the same thing, and so creating a ConceptNode that
encompases all of these noun instances.  This can be crudely represented
as the pseudo-code:

   IF (for-all parses of all sentences in same document)
       AND (word-instance-1 == noun)
       AND (word-of-word-instance-2 == word-of-word-instance-1)
       AND ...
       AND (word-of-word-instance-k == word-of-word-instance-1)
   THEN (create concept-node encompassing word-instances 1 thru k)

It would be "easiest" to code up above in C++ or Scheme (or Java or
Python or ...) but this missses the point: The opencog system will
need to be able to modify the above rule (or algorithm) based on
learned, statistical experience, for example, by adding more
AND-clauses to refine the action.

Another example: The consistency of this reference assignment can be
checked using the following pseudo-code:

   IF (word-instance-1 is-grouped-wth word-instance-2 in same concept)
      AND (word-instance-1 has property-A)
      AND (word-instance-2 has property-B)
      AND (property-A is inconnsistent with property-B)
   THEN (word-instance-1 and word-instance-2 should be ungrouped,
        and are probably distinct concepts)

The above pseudocode would help resolve text such as "Jurate held a red
balloon. Kastytis held a green balloon." The intitial reference
resolution would assign both word instances to the same object-instance
(i.e. assume that both words refer to just one balloon). The consistency
checker would note that the the color property is inconsistent, and thus
conclude that these are probably not refering to the same object. (And
tus, the combined-concept should be assigned a truth value close to
"false", and two new, distinct object-instance-concepts should be
created.

The core OpenCog nodes and links to be used to represent such rules are:
   VariableNode  -- to indicate a variable
   ImplicationLink -- to represent an if..then.. relationship.

Below is an example of the use of the ImplicationLink.

   "If the case is near the mouse and the cat is hungry, the cat will
   eat the mouse".

   ImplicationLink
   ___ANDLink
   ______ Inheritance $var0 cat
   ______ Inheritance $var0 hungry
   ______ EvaluationLink
   ___________ Node near
   ___________ ListLink
   _______________VariableNode $var1
   _______________VariableNode $var0
   ______ InheritanceLink $var1 mouse
   ___EvaluationLink
   ______Node eat
   ___________VariableNode $var0
   ___________VariableNode $var1


In practical terms, as the above shows, the encoding of rules will
likely be quite verbose. For the next example, consider two word
instances, using the current RelEx output format.

In the following, we will use the word "axiom" for "rule".
Each such rule has the structure of an implication, in Skolemized form,
with a list of variables up front, an antecedent (the "if" clause),
and a consequent (the "then" clause).  The antecedent is a list of
clauses that must be satisfied, the consequent is a set of nodes to
be created/modified.

   (VariableScopeLink
      ; A list of the variables in the "rule" or "axiom".
      ; This list essentially acts as a type declaration for
      ; the variables in this axiom.
      (ListLink
         ; Type declaration: $word-inst-0 is a word instance
         (WordInstanceNode $word-inst-0)
         (WordInstanceNode $word-inst-1)
         (ParseNode $parse-0)
         (ParseNode $parse-1)
         (SentenceNode $sentence-0)
         (SentenceNode $sentence-1)
         (DocumentNode $document)
         (ConceptNode $concept)

         ; The variable $word *must* be a WordNode
         (WordNode $word)
      )

      ; What follows is a conjunction of expressions
      ; that must be satisfied for this "axiom" to hold.
      (AndLink

         ; The word-instance must be nouns.
         (PartOfSpeechLink
            (VariableNode $word-inst-0)
            (DefinedLinguisticConceptNode "noun")
         )
         (PartOfSpeechLink
            (VariableNode $word-inst-1)
            (DefinedLinguisticConceptNode "noun")
         )

         ; The word-instances must refer to the same word.
         (LemmaLink
            (VariableNode $word-inst-0)
            (VariableNode $word)
         )
         (LemmaLink
            (VariableNode $word-inst-1)
            (VariableNode $word)
         )

         ; The word-instances must belong to the same document.
         ; This is done by making sure that they belong to parses,
         ; which belong to sentences, which belong to documents.
         ;
         ; XXX to-do: the number of words in a sentence is variable.
         ; Its not clear how to match this, given the structure below!
         (ReferenceLink
            (ParseNode $parse-0)
            (ListLink
               (VariableNode $word-inst-0)
            )
         )
         (ParseLink
            (ParseNode $parse-0)
            (SentenceNode $sentence-0)
         )
         (ReferenceLink
            (ParseNode $parse-1)
            (ListLink
               (VariableNode $word-inst-1)
            )
         )
         (ParseLink
            (ParseNode $parse-1)
            (SentenceNode $sentence-1)
         )
         (ReferenceLink
            (DocumentNode $document)
            (ListLink
               (SentenceNode $sentence-0)
               (SentenceNode $sentence-1)
            )
         )
      ) ; end of AndLink (the antecedent, or "if" clause)
      ; Above is the conjunction of clauses that must hold

      ; Next the consequent, or "then" clause.
      ; Create a single concept, which encompases each of these word
      ; instances, implying that they all refer the to same overall
      ; concept.

      ; XXX somehow generate a new UUID for this new concept!
      ; use a combo tof the word, and the document, to help identify it.
      (ConceptNode $concept)
      (ExtensionalInheritanceLink
         (ConceptNode $concept)
         (WordInstanceNode $word-inst-0)
      )
      (ExtensionalInheritanceLink
         (ConceptNode $concept)
         (WordInstanceNode $word-inst-1)
      )
   )


Application of Rules
====================
Possibilities:
1) Adapt existing "query" code, which does general pattern matching,
   (i.e. is capable of matching to VariableNodes) to be able to apply
   above rules.

2) Make use of PLN forward or backward chainers to do same.
