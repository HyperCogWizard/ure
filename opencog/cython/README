Python bindings for OpenCog, the General Artificial Inteligence (GAI)
research framework. http://opencog.org/
=======================================

Written by Joel Pitt <joel@opencog.org>

Requirements:
 - Python 2.6 or later - these bindings may work with earlier version, but
   they have not been tested at all.
 - Cython 0.14 or later. http://www.cython.org/
 - Nosetests - for running unit tests.

Both Cython and Nosetests can be installed with easy_install:

 sudo easy_install cython nose

The bindings are written mostly using Cython, which is an awesome language for
writing code that look pythonic but gets compiled to C (and then machine code
by gcc or your favourite compiler). It also makes it trivial to access
both Python objects and C objects without using a bunch of extra Python library
API calls.

Currently the package structure looks like this:

 opencog.atomspace
 opencog.atomspace.types
 opencog.cogserver

Eventually, when other components of OpenCog are accessible, they'll follow a similar pattern:

 opencog.pln
 opencog.rules
 opencog.moses

== Tutorial == 

This tutorial is a first look at the Python bindings. It assumes that you've got a good grasp on the concept of the AtomSpace and the CogServer. Oh, and it helps to know a bit of Python too!

=== Setting up ===

Go through the normal process of [[building OpenCog]]. Then ensure that the
OpenCog data directory is in your Python path. By default this is at
/usr/local/share/opencog/python, and you can modify your PYTHON_PATH
environment variable:

 $> export PYTHON_PATH=/home/joel/src/opencog/bin/opencog/cython

=== AtomSpace API ===

One great thing about these bindings is that they let you interact and
instantiate your own AtomSpace objects interactively. I recommend [[ IPython]],
which is a very capable Python shell. Prior to this, the only
interactive way
of modifying the AtomSpace was using the Scheme bindings embedded in active
CogServer, and even then you'd only be able to modify the core CogServer
AtomSpace. 

Without further ado, here's how to add a node:

 from opencog.atomspace import AtomSpace, types

 a = AtomSpace()
 a.add_node(types.ConceptNode, "My first python created node")

 Return value: <opencog.atomspace.Handle object at 0x203fa80>

Of course, to make things more succinct when referring to types you can alias stuff:

 t=types
 a.add_node(t.ConceptNode, "Ah, more concise")
 ConceptNode = t.ConceptNode
 a.add_node(ConceptNode, "Ah, more concise")

You'll notice these return Handle objects, which internally store a UUID and that allow you refer to the Atom later:

 h = a.add_node(ConceptNode, "handle bar")
 print str(h)
 Output => '<UUID:4>'

Or you may get a different UUID. Now, the handle object can't do a lot on it's
own, so we wrap it in a helper class called Atom (the "Handle" may eventually
disappear from the Python API as it's only really important for
low-level graph storage and lookup). The Atom class ties the Handle to the AtomSpace an request the information from the AtomSpace as required.

 from opencog.atom import Atom
 an_atom = Atom(h,as)
 print str(an_atom)
 Output => 'node[ConceptNode:handle bar]'
 print an_atom.long_string()
 Output => 'node[ConceptNode:handle bar] av:(0,0) tv:([0.000000,0.000000=0.000000])'
 print an_atom.name
 Output => 'handle bar'
 print str(an_atom.t)
 Output => '3'
 from opencog.atomspace import get_type_name
 print get_type_name(an_atom.t)
 Output => 'ConceptNode'

Note that on the second reference to an_atom.t, it won't recheck the AtomSpace
for the atom type because it's immutable and gets cached internally. If you try
to set an immutable property of an Atom, you get an AttributeError exception:

 an_atom.name = 'change your name man, it sucks.'
 ---------------------------------------------------------------------------
 AttributeError                            Traceback (most recent call last)
 /home/joel/src/opencog/examples/python/<ipython console> in <module>()
 AttributeError: attribute 'name' of 'opencog.atomspace.Atom' objects is not writable

I guess the 'handle bar' Atom is stuck with it's amusing but unfortunate name.

Now, just adding the [[atom]] isn't that useful if we can't refer to it later.
So let's reme,ber the handles of a couple of nodes and create our first link:

 n1 = a.add_node(t.ConceptNode, "I can refer to this atom now")
 n2 = a.add_node(t.ConceptNode, "this one too")
 l = a.add_link(t.SimilarityLink, [n1,n2])



Note: It occurs to me that it'd be trivial to replace add_node/add_link with a simple add method. So next round of improvements will probably have this. It'd also be nice to somehow import types using "from opencog.atomspace.types import ConceptNode" (or use a * import)

=== MindAgents in Python ===

MindAgents modify the AtomSpace autonomously. Adding and removing atoms,
updating TruthValues or anything else. The most important part for now is
the "run" method, which gets called with the CogServer AtomSpace as a parameter
(In the past, C++ MindAgents would be passed the CogServer itself, but it
wasn't obvious to me why this is necessary).

 import opencog.cogserver
 from opencog.atomspace import types

 class MyMindAgent(opencog.cogserver.MindAgent):
     def run(self,atomspace):
         atomspace.add_node(types.ConceptNode, "test")

This will try, every CogServer cycle, to add the ConceptNode called "test".
 
''Warning'': Note the opencog.cogserver.MindAgent is subclassed using the full
path. If you use:

 from opencog.cogserver import MindAgent #wrong

Then you'll get MindAgent showing up in the cogserver too. I'm not currently
sure why, but supporting this is another improvement to add eventually.

=== CogServer Requests in Python ===

CogServer Requests are commands that can be issued in the shell or by other
modules in the code. Allowing Python code to instantiate requests would be
a simple way to make Python code callable from C++.

== Improving the bindings ==

See the Cython documentation, and then check out the source code in
SOURCE_ROOT/opencog/cython/opencog. Note the use of Cython .pxd definition
files which show how to make C++ classes and functions available to cython
code.


