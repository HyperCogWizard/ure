                    query
                    -----

Simple, experimental implementation of query processing
pre-prototype, broken, doesn't do anything yet.

Conceptual problems, design problems:
-------------------------------------
-- How to distinguish rhetorical questions from queries that should
   be answered?  A block of input text may contain rhetorical questions,
   which should be ignored.

-- How should query processing be triggered?  What channel should be 
   used for reply? Currently, all input to CogServer is via XML, which 
   is parsed. If the parse is successful, no further processing is done. 

   Query processing could be performed by a mind agent, but how should
   its activity be triggered, and what communictations channel should
   it use to post a reply?


Diary and Notes
---------------
Use special token to trigger mind agent. Per Ben, "DialogManager",
there are for such tokens:
-- query
-- statement
-- command
-- interjection

Right now, all four of these will be surrounded by an AssertionLink.
The query processor will look for  these, perform some basic sentence
analysis, and dispose of these as appropriate (i.e. generating an
appropriate reply).

Hmmm .. queries need to be morphed into predicates !?
i.e. use a PredicateNode, and an EvalLink

Terminology
-----------
The incidence graph of a hypergraph is called the "Levi graph".
Levi graphs are bipartite.

The Basic Algorithmic Idea
--------------------------
The basic idea is to treat the query as a graph, in which are embedded
one or more unknowns. This query graph can be loosely understood to be
a predicate, with the unknowns corresponding to the bound variables of
the predicate.

The goal of query processing is to scan the collection of all knowledge,
looking for a subgraph that matches the predicate. The nodes that fit
where the unknowns would go are then the answer to the query.

The problem of finding certain subgraphs within graphs is known as the
"subgraph isomorphism problem" or the "subgraph matching problem", and 
one uses a "subgraph isomorphism algorithm" to find the match.


Currently Implemented Algorithm
-------------------------------
0) In the following, the word "atom" may refer to either a hypergraph
   node, or a hypergraph edge. Corresponding to every hypergraph is
   an incidence graph. The atoms of a hypergraph are vertices of
   the incidence graph. The convetion used here is that the incidence
   graph is a directed graph; thus, only hypergraph links have 
   outgoing incidence graph edges; whereas hypergraph nodes have
   no outgoing incidence graph edges.

   The implemented algorithm makes direct use of the incidence 
   graph, and only indirectly to the hypergraph. The insistence
   on making the incidence graph be a directed graph helps make
   traversal more direct and removes ambiguity.

   [OpenCog-specific remarks are in square brackets.  In OpenCog, the 
   outgoing incidence graph edges are given by the "outgoing set" of 
   the atom.]

1) Input consists a sequence of the roots of incidence trees, that is,
   of a list of subgraphs of the incidence graph that are trees.  Thus,
   by definition, the incidence tree root must be a hypergraph link, 
   as hypergraph vertex cannot, by definition, have a non-trivial 
   incidence tree under it.  Each tree is, by definition acyclic.

   Thus, for example: _subj(row, Steve) has _subj at the root of the 
   tree, with row and Steve as leaves.

   Each tree will be refered to as a "predicate" in the following.
   Distinct trees may have common verticies. The collection of trees,
   as a whole, may contain loops. The collection of trees, as a 
   whole, must be connected; no disjoint graphs allowed.

2) Input includes a list of the bound variables in the expressions.
   Thus, for example _obj(row,_$qVar) has _$qVar is the variable
   to be solved for. The list serves to explicitly identify the 
   variables, so that they do not need to be computed or guessed.
   The designated variables need not be leaf verticies. There may be
   more than one variable; there must be at least one.

3) Pick the first tree. Get the type of the root atom of the 
   first tree. Get a list of all atoms in the universe of this type. 
   These are the "candidate atoms".  Iterate over this list.
   The iterator is the next step below (step 4).

   [This step is implemented in PatternMatch::match(), which calls
   PatternMatch::do_candidate() for each candidate root.]

4) Initiate a recursive tree matching algorithm, comparing the 
   incidence tree of the first predicate to that rooted at the 
   candidate atom.

   The tree matching algorithm is the appropriate place to implement 
   any special-case tests and match requirements, such as matching 
   types or labels on hypergraph atoms.

   [This step is implemented in PatternMatch::tree_compare()
   Several "special case tests" are applied at this point. The
   most important one is in the comparision of nodes. The predicate
   nodes are considered to match nodes in the universe when both nodes
   are "is-a" instances of the same concept. So, for example, the
   assertion _obj(throw_123, ball_456) is understood to be instance 123 
   of the general concept of "throwing", and ball_456 is instance 456 of
   the general concept of "ball". To answer the query "Who threw the 
   ball?", the "ball" in the predicate will be a specific instance of
   "ball", (e.g. "ball_789"), and we want to match on the concept,
   not the instance.

   These specifics may need to be modified if there is reasoning 
   performed prior to the query, or it the overall representation of
   the relex and frame structures in opencog change.]

	If the tree contains bound variables, the corresponding atom in
   the universe graph is marked as a solution candidate.

5) Do other trees .... 
